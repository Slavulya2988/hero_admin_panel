https://redux-toolkit.js.org/api/configureStore
configureStore

Стандартный метод создания хранилища Redux. Он использует внутри низкоуровневый метод createStore ядра Redux, но оборачивает его, чтобы обеспечить хорошие настройки хранилища по умолчанию для улучшения разработки.

configureStore from Redux Toolkit
 1. импорт configureStore  із toolkit
 2. створюємо хранилище з наступними параметрами:
  reducer - об'єкт із усіх редьюсеров
  middleware - берем внутренную функцію редикс-тулкіт getDefaultMiddleware и присоединям наш /middleware
  devTools - подключаем со значение True только для режима розробки

 --
 https://redux-toolkit.js.org/api/createAction

 createAction

 Вспомогательная функция для определения типа и создателя действия Redux.
 createAction объединяет два объявления в одно. Он принимает тип действия и возвращает создателя действия для этого типа. Создателя действия можно вызвать либо без аргументов, либо с привязкой полезных данных к действию.

 --
 https://redux-toolkit.js.org/api/createReducer

 createReducer

 Утилита, упрощающая создание функций редуктора Redux. Он использует Immer внутри, чтобы радикально упростить неизменяемую логику обновления путем написания «мутативного» кода в ваших редукторах, и поддерживает прямое сопоставление определенных типов действий с функциями редуктора регистра, которые будут обновлять состояние при отправке этого действия.

 --
 https://redux-toolkit.js.org/api/createSlice

 createSlice

 Обединяет в себе createAction и createReducer
 файл слайса создается возле компонента
 сама функція createSlice принимает 4 аргумента:
 1. name: string - имя нашего среза - пространство имен создаваемих действий actions
 2. initialState: State - начальное состояние редьюсера
 3. reducers - об'ект с обработчиками
 4. extraReducers - редьюсери другого среза


 когда єта функція отработает она вернет три разние сущности:
 1. имя нашго среза
 2. обект с екшенами
 3. редьюсер
 --
 https://redux-toolkit.js.org/api/createAsyncThunk

 createAsyncThunk - позволяет создать стадартний редакс AsyncThunk екшен крейтор с дополнительними свойствами
 для роботи с промисами
 импортируем цю функцію в файл со слайзами
 импортируем хук Http для получения request
 также сущность createSelector можем брать не из библиотеки reselect а из библиотеки Redux Toolkit
 создаем функцию в которую передаем несколько аргументов:
 первий - имя среза/тип действия - просто строка - із документації type
 второй - функція (payloadCreator) которая должна вернуть промис, т.е. асинхронний код , ця функція в свою очередь
 принимает еще два аргумента: первий єто то что приходит при диспатче єтого действия (arg) , например какая то ИД,
 а второй аргумент  єто апи самого фанка - thunkAPI
 В нашем случае payloadCreator будет визиваться без аргументов
 внутри функции - то что ми должни виполнить, в нашем случае = єто реквест.

 команда createAsyncThunk возвращает три екшен крейтора: pending, fulfilled и rejected
 задача: обработать три екшен крейтера и запустить готовий екшен крейтор в нужном месте
 1. задача решается в createSlice в разделе extraReducers, через конструкцію bulder и команд addCase
 обрабативаеь pending, fulfilled и rejected (дивись в документації методи для createReducer())

 те обработчики запросов которие раньше били в редьюсере можна убрать
 в редюсерах устануть дествия по изменению действий, а createAsyncThunk будет обрабативать только загрузку даних

 2. в файле где брали асинхронную функцю перенаправить на новое месторсположение,
 у нас єто в HeroesList берем із heroesSlice

 еще надо доработать хук useHttp - убрать useCallback.

--
createEntityAdapter

https://redux-toolkit.js.org/api/createEntityAdapter

В редьюсере есть функции (heroDelete, heroAdd) которие хотелось би поменять на більш общие команди
удалить одну сущность, добавить сущность або взагалі мати набор готових команд.
В цьому ціль createEntityAdapter.
По своей сути це функція которая возвращает обект - адаптер, с готовими методами, колбеками, мемоизированими селекторами и определенной структури - CRUD операціі.

Методи которие будут возвращаться із єтой функціі будут маніпулировать даними, которие заключени в структуру:
{
 // массив с унікальними ідентифікаторами
  ids: []
  // обект с различними сущностями
  entities: {
  }
}

1. импортируем createEntityAdapter в heroesSlice.js
2. создаем переменную heroesAdaptor и присваиваем ей визов функции createEntityAdapter
3. после его создания ми используем  его при создании слайза как начальное значение за доппомогою функціі getInitialState()
4. с помощь визова console.log(initialState) можно увидеть что ми получили обект со свойствами:
  ids: []
  entities: {}
5. передаем в функцию getInitialState() дополнительное свойсто  heroesLoadingStatus: 'idle'
6. при обїявление адаптера можно его донаставить добавляя нужніе команди, но в нашем случае єто не надо так как данние у нас в джейсон файле нужной структури
7. теперь возпользуемся методами createEntityAdapter для заплнением даних после запроса:
в нашем случае єто setAll - установить всех героем с параметрами (state, action.payload)
state - куда помещаем данние
action.payload - что 
8. также воспользуемся методом getSelectors для получения selectAll и дальше используем ету функцию в компоненте HeroesList в createSelector для получения всех героев
9. воспользуемся методами адаптера removeOne і addOne для удаления и добавления героя.
